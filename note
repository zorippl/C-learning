1.内存扩展
    1.int *p; p=new 类型[初值]在堆区开辟空间，并返回一个指向该地址的指针。
    2.delete p; 释放堆区的空间，当开辟的是数组时，释放要用delete[] p;
    3.内存对齐 #pragme 具体看CSDN
2.函数进阶   
    1.函数内的形参加const修饰防止被篡改。
    2.函数可以在定义形参中赋给默认初值，传入了用我传的，没有传入就用默认初值。
        ·如果函数某个位置有了默认参数，那么这个位置往后都得有默认传输。
        ·如果函数声明有默认参数，那么函数实现就不能有默认参数。
    3.函数重载：函数名相同，在同一个作用域内，参数的设定不完全相同。
        调用时必须在重载函数中只有一个满足条件能进，否则有二义性，会报错。
3.类和对象
    1.类中的属性和行为统一称为成员。
        ·属性也叫成员属性 成员变量。
        ·行为也叫成员函数 成员方法。
    2.类的权限分为public,private, protected三种，没有写前缀时默认为private型，类外无法访问。
        ·一般将属性写在private内 接口方法写在public中。
    3.类调用时会默认执行构造函数[无参，函数体为空][初始化类]，类释放时会默认调用析构函数[无参，函数体为空][清理类]，
    会额外给类添加默认拷贝构造函数，用于对属性值进行拷贝。
        ·构造函数为 类名(){},可以带参数，析构函数为 ~类名(){},不可以带参数。
        ·构造函数按参数分为有参构造和无参构造；按类型分为普通构造和拷贝构造。
        ·构造函数调用方法有括号法[隐式法]，显示法，隐式转换法。
        ·拷贝构造函数调用时机[也就是需要拷贝副本的时候]。
            1.使用一个已经创建完毕的对象来初始化一个新的对象。
            2.值传递的方式给函数参数传递值。
            3.以值方式return局部对象。
        ·用户定义有参构造函数，编译器不再提供无参构造，但是提供拷贝构造。
        ·用户定义拷贝构造函数，编译器不再提供其他构造函数。
        ·浅拷贝：简单的默认的赋值拷贝操作；深拷贝：在堆区重新申请空间进行拷贝操作。
            1.当类中存在指针存放堆区开辟[new]的地址时，若采用浅拷贝，两个对象中的指针指向同一个地址，无法释放[delete]两次。
              解决方法:自行设计拷贝构造函数，手动进行深度拷贝，申请堆区空间。
        ·构造函数可以有列表式：类名(类型 形参名): 形参名1(初值), 形参名2(初值){}
        ·当类的成员中有其他类的对象时，先执行对象的构造函数，再执行自己本身的构造函数；而析构函数的执行顺序则相反。
    4.静态成员需要在类内声明，类外初始化，类内[static 类型 变量名]类外[类型 类名::变量名 = 初值]
        ·静态成员变量是所有对象共享的，可以通过具体的对象去访问[对象名.成员名]，或者直接通过类名去访问[类名::成员名]。
    5.静态成员函数内只能访问静态成员变量，并且所有对象共享静态成员函数。
    6.空对象占用一个字节，只有非静态成员变量占用对象内存。
    7.this指针指向被调用的成员函数所属对象，可以用于区分形参和成员变量名，或是在类的非静态成员函数中返回对象本身[return *this]
    8.空[NULL]指针访问成员函数时，如成员函数内请求访问了成员变量，会因为this指针也为空而报错，应在函数内判断this若为空则return。
    9.常成员函数和常对象
        ·常成员函数就是在成员函数后加const,相当于定义的this指针为[const 类名 * const this]。
        ·常成员函数中只能修改常成员变量，除非在成员变量前加[mutable]进行修饰。
        ·常对象只能调用常成员函数，并且无法修改没有加[mutable]修饰限定的成员变量。
    10.友元
        ·全局函数做类的友元，只要在类中最前端声明[friend 返回值类型 函数名(参数)]。
        ·类做类的友元，只要在类中最前端声明[friend class 类名]。
        ·成员函数做类的友元，只要在类中最前端声明[friend 类名::返回值类型 函数名(参数)]。
    11.运算符重载
        ·相当于自定义不同数据类型的运算符运算规则函数，可以写作成员函数或者是全局函数，有本质调用[函数调用]和简化调用[运算调用]，可以发生函数重载。
        ·重载左移运算符配合友元可以输出自定义数据类型[cout << 自定义类型]
        ·自定义自增自减运算符时，前置运算返回引用，后置运算返回值，写后置发生函数重载时在参数内写(int)占位符。
        ·重载赋值运算符可以解决浅拷贝带来的重复释放栈区内存的问题。
    12.继承
    13.多态
        1.两种多态的区别和特点
            ·静态多态：函数重载 和 运算符重载[函数地址在编译阶段确定和绑定]
            ·动态多态：派生类和虚函数实现运行时多态[函数地址在运行阶段确定]
        2.多态满足的条件
            ·有继承关系
            ·子类重写[函数完全一致称为重写]了父类中的虚函数(virtual修饰的函数)
        3.多态使用条件
            ·父类指针或引用指向子类对象
        4.纯虚函数和抽象类
            ·纯虚函数就是virtual 返回值类型 函数名 (参数列表) = 0；
            ·有纯虚函数的类叫抽象类，抽象类无法实例化对象。
            ·子类必须重写抽象类中的纯虚函数，否则该子类也属于抽象类。
        5.虚析构函数和纯虚析构函数
            ·如果子类中有属性开辟到堆区，父类指针在释放时无法调用子类的析构代码。
            ·两者共性：都可以解决父类指针释放子类对象；都需要有具体的函数实现。
            ·两者区别：纯虚析构函数的所在类属于抽象类，无法实例化对象。
            ·如果子类中没有开辟的堆区数据，可以不写虚、纯虚析构函数。
